## Lab5实验报告

计65 2015010207 钱姿

### 【练习0】填写已有实验

将实验1、2、3、4填入代码中

根据注释修改之前实验中的代码

* LAB1修改

  * 初始化中断向量表

    代码如下

    ```C++
    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
    ```

  * 每个时钟周期增加处理

    ```C++
    //需要注释掉之前的print_ticks()
    assert(current ！= NULL)；
    current->need_resched = 1;
    ```

* LAB4修改

  * 函数alloc_proc中增加对四个新增字段的初始化

    ```C++
     proc->wait_state = 0;
        proc->cptr = NULL;
        proc->yptr = NULL;
        proc->optr = NULL;
    ```

  * do_fork函数中增加功能

    * 确保当前进程中在等待

      ```C++
      assert(current->wait_state == 0); 
      ```

    * 增加执行set_links函数

      ```c++
      //注释掉之前的简单的计数 
      set_links(proc);
      ```

### 【练习1】加载应用程序并执行

需要修改在kern/process/proc.c文件的load_icode函数，需要设置新创建的用户进程中的trapframe中的内容，以便该进程从内核态返回后能够正确的在用户态执行。那么tf_cs需要为USER_CS,DS,ES,SS等都需要设置位USER_DS,ESP设置为用户地址的栈顶，EIP设置为加载程序的入口地址。

具体的代码实现参考注释为

```C++
tf->tf_cs = USER_CS;
tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
tf->tf_esp = USTACKTOP;
tf->tf_eip = elf->e_entry;
tf->tf_eflags = FL_IF; 
```

* 请在实验报告中描述当创建一个用户态进程并加载了应用程序后，`CPU`是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被`ucore`选择占用CPU执行（`RUNNING`态）到具体执行应用程序第一条指令的整个经过。
  * ucore通过do_execve函数来完成用户进程的创建工作
    * 首先为加载新的执行码做好用户态内存空间清理准备
    * 接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。
  * load_icode函数的主要工作就是给用户进程建立一个能够让用户正常运行的用户环境
  * 在do_execve函数推出后，顺次返回到syscall函数，trap_dispatch函数，trap函数。此时，传入的trapframe内容已经修改，也就是说此时的栈中的内容就是函数中设置的trapframe
  * 用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令iret后，将切换到用户进程的第一条语句位置（根据`tf_eip`的值）开始执行。`iret`指令执行时，会依次`pop eip，CS，EFLAGS`，然后判断`CS`中的特权级标识。由于我们之前设置的`CS`为`USER_CS`，那么`CPU`会知道我们需要从内核态返回用户态，因此还会`pop`出`SS`和`esp`。由于`SS`和`esp`指向的是用户态地址空间，另外`trapframe`中的`eip`还被设置为了加载的程序的`entry`地址，因此在`iret`返回之后，就会在用户态开始运行被加载的程序

### 【练习2】父进程复制自己的内存空间给子进程

根据代码注释完成下列代码：

```C++
//获取父进程的虚拟页地址
void * kva_src = page2kva(page);
//获取子进程的虚拟页地址
void * kva_dst = page2kva(npage);
//拷贝父进程到子进程
memcpy(kva_dst, kva_src, PGSIZE);
//设置页表的映射关系
ret = page_insert(to, npage, start, perm);
```

* 给出COW的设计思路

  `“Copy on Write”`机制需要在执行`do_folk`函数的时候不新分配物理页面并将原进程页面中的内容拷贝至新分配的物理页面，而是拷贝原来进程的整个页表，并把所有页面的权限都设置为只读。

  这样的话，新进程实际上共享了原进程的物理内存。如果新进程对某个页面进行写操作，由于页面的权限都是只读，就会产生一个`page fault`，我们就可以在`do_pgfault`中检测到这个问题，并分配新的物理页面，重新建立页表，进行数据拷贝，异常处理返回之后新进程就可以在新分配的物理页面进行写操作而不影响原来进程的数据了。

### 【练习3】理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

* fork函数分析

  - 通过`alloc_proc()`分配并初始化进程控制块
  - 通过`setup_stack()`分配并初始化内核栈
  - 复制或共享进程内存管理结构
  - 设置进程中断帧和执行上下文
  - 把设置好的进程控制块放入`hash_list`和`proc_list`两个全局进程链表中
  - 将进程状态设置为“就绪”态
  - 设置返回码为子进程的`id`号

* exec函数分析

  - 首先为加载新的执行码做好用户态内存空间清空准备。
  - 如果`mm`不为`NULL`，则设置页表为内核空间页表，且进一步判断`mm`的引用计数减`1`后是否为`0`，如果为`0`，则表明没有进程再需要此进程所占用的内存空间，为此将根据`mm`中的记录，释放进程所占用户空间内存和进程页表本身所占空间。
  - 最后把当前进程的`mm`内存管理指针为空。由于此处的`initproc`是内核线程，所以`mm`为`NULL`，整个处理都不会做。

* wait函数分析

  父进程有两个可调用的函数来回收子进程：wait，wait_pid，区别是wait等待任意子进程结束的通知，而wait_pid只等待特定子进程的通知。两个函数最终访问系统调用接口，让ucore来完成对子进程最后的回收

* exit函数分析

  函数最终访问sys_exit系统调用接口让操作系统来帮助当前进程执行退出过程中的部分资源回收。

  首先exit函数会把一个推出马传递给ucore，ucore通过执行内核函数do_exit来完成对当前进程的推出处理，主要工作是回收当前进程所占的大部分内存资源，并通知父进程完成最后的回收工作。

* 系统调用的实现

  应用程序调用上述函数最终都会调用syscall函数，只是调用的参数不同。应用程序将请求的系统调用编号放入`eax`，系统调用的参数放在`edx、ecx、ebx、edi、esi`寄存器，然后执行INT 0x80指令请求操作系统完成系统调用。操作系统根据中断号0x80得知是系统调用，根据系统调用号和参数执行相应的操作。

* 分析上述函数如何影响进程的执行状态？
  * fork创建新进程，原进程在执行系统调用后直接返回，继续保持运行状态（不受影响），而新进程也是可执行状态
  * exec调用完毕后，原进程继续执行；若调用失败，原进程可能变成僵尸态
  * wait会寻找该进程的处于僵尸状态的子进程。如果找到，那么释放该子进程的资源，wait调用返回，父进程依然保持运行状态。如果没有找到，会将该进程设置为等待状态，然后对其他可运行的进程重新进行调度。
  * exit执行后当前进程由运行态变为僵尸态。

### 与参考答案的区别

基本思路无区别

### 实验中涉及的重点知识

进程的创建和执行

进程创建和空间分配

### 实验中为涉及的重点知识

用户线程

轻量级线程